##1 gradientu X
gradient_x = cv2.Sobel(img,cv2.CV_64F,1,0,ksize=5)
return np.median(gradient_x)


##2 rezultat konwolucji obrazu
f = np.array([[-1,-2,-1], [0,0,0], [1,2,1]])
conv = cv2.filter2D(img, cv2.CV_32F, f)
return conv

##3 Uzupełnij funkcję get_indices tak, aby zwracała listę wszystkich indeksów pikseli o wartości val z obrazu img. Indeksy powinny być w postaci krotki (y,x)
x = np.array(np.where(img == val)).T
x = [tuple([i[1], i[0]]) for i in x]
return x

##4 Napisz funkcję, która przyjmuje obraz kolorowy img i zwraca wartość kanału niebieskiego na pozycji lewy gorny rog
return img[y,x,2]

##5 Uzupełnij funkcję tak, by dokonywała reshapingu
return np.ravel(img).reshape((img.shape[0]*img.shape[1],1))

##6 Uzupełnij funkcję get_greater_indices
indices = np.where(img > val)
return list(zip(indices[0], indices[1]))

##10 Uzupełnij funkcję tak, aby zwracała średnią wartość gradientu Y (z filtra sobela) na obrazie img (skala szarości)
sobel_y = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=5)
return np.mean(sobel_y)

##11 Napisz funkcję, która przyjmuje obraz kolorowy img i zwraca wartość kanału
niebieskiego na pozycji środkowego piksela
h, w, _ = img.shape
  return img[h//2, w//2, 2]



